> _MySQL, timestamp의 Group By 메서드_

- MySQL을 사용하면서, timestamp의 Year, Month 데이터만 뽑아서 SQL문의 조건문으로 사용하는 방법이 없을까? 라는 생각에 의해 찾아보게 되었다. 당연하게도 방법은 MySQL 공식 문서에 대문짝만하게 작성되어 있었다. 기존에 불필요하게 생성하였던 시간에 대한 컬럼들을 삭제할 수 있게 되어 데이터베이스의 용량을 아끼게 되었다.
- 이처럼 다양한 MySQL에서 제공하고 있지만, 내가 정확하게 알지 못해서 사용하지 못하는 부분들이 많다. 또한 MySQL 뿐만 아니라 다른 스택들에서 내가 찾아보지 않아서 사용하지 못하는 부분들이 분명히 많을 것이라고 생각된다.
- 이번에 서비스를 리모델링하면서 AWS, DB, Server를 순서대로 구축하게 될 예정이다. 서비스에서 백엔드 전반에 대한 충분한 지식이 없는 상황이지만 지금 시간을 충분히 소화해낸다면 그래도 어디가서 백엔드 엔지니어라고 말 할 수 있을 것이라고 생각한다.

> _Schedule - Diary, Ledger 정규화_

- 데이터베이스 정규화 개념을 배우면서 이전에 만들었던 테이블에 직접 적용해보았다. 각 단계별로 정규화를 적용하면서 각 릴레이션의 속성들이 정규화 과정을 거치면서 정리되어가는 것을 경험하였다. 내가 부족함을 느낀 부분은 데이터 중복을 제거하는 과정에서 나타났다.
- 날짜 데이터의 중복으로 인해 하나의 날짜 데이터만 가져가는 테이블을 만들고 해당 날짜 데이터를 가진 레코드의 기본키로 Diary와, Ledger의 FK로 만들어 하나의 날짜 데이터와 연결되도록 만들고자 했다. 하지만, 데이터의 중복에만 치우쳐진 생각이었다. 이전에 테이블을 생성할떄는 속성값의 중복보다는 SQL문 작성 시 가장 효율적인 릴레이션 생성 방법을 생각했다면 정규화 개념을 도입하기 위해 데이터의 중복만을 생각하며 테이블을 나누다 보니 실제 쿼리 시 좋지 않은 SQL문과 어떤 면에서는 불가능에 가까운 테이블을 생성하기 까지 했다.
- 예를 들면 기존에는 Diary와 Ledger에 각각의 Date가 있었다. 하지만, 이 Date 부분이 중복되게 작성되었고, 이 부분을 데이터 중복을 삭제해야겠다고 생각했다. 하지만, 실제로 Diary나 Ledger의 상세 데이터 생성하기 위해서는 Schedule 테이블에 있는 Date 속성만 있는 테이블에 해당 Date를 생성한뒤, 해당 속성의 key를 이용해야 하기 때문에 불필요한 SQL요청이 증가하게 되는 결과를 가져온다.
- 데이터의 중복은 피할 수 있지만, SQL 요청 횟수가 증가하게 되는 결과를 가져오게 된 것이다.
- 내가 오해한 부분은 데이터의 중복에서 중, 어느정도 데이터의 범위가 정해진 컬럼에 대한 중복을 제거하는 것이 정규화에서 말하는 데이터의 중복을 피해야 한다는 의미라고 생각된다. 그렇다면 Date의 중복은 역정규화인가?를 생각해보면, 우선 역 정규화는 실제 데이터 사용의 효율을 위해 정규화 이론에 위배되는 중복을 넣는 것이다. 그렇다면 Date의 중복 허용은 역정규화를 했다고 생각된다.

> _Cascade update 옵션 기능 확인_

- TypeORM에서 제공하는 Cascade update 기능에 대한 이해가 부족했나? 라는 생각을 한다. 지금은 릴레이션을 정의한 부분에서 테이블 간 관계를 정의하고 있다. 이 관계 정의 과정에서 적용하는 속성이 Cascade이다. 지금은 Cascade: boolean 밖에 사용하지 않고 있다. 이 옵션에서 [ “update” ] value를 적용하면 속성과 관계를 가진 데이터가 update되면 다른 테이블의 연결된 테이블의 데이터 또한 update하는 경우에 사용하게 된다.
- 그렇가면, 만약 하나의 req.body에 관계를 맺은 서로 다른 테이블의 속성들을 한꺼번에 Save하면 관계를 위한 속성값에 맞게 적용되어 다른 테이블의 레코드의 key가 없어도 자동으로 생성, key가 있는 경우는 업로드가 진행된다는 것일까 ?
- 만약 이게 된다면, 조금 더 깔끔한 서버 로직을 생성할 수 있을 것이라고 생각한다. 내일 나름대로의 DB정규화를 진행해보고, 시니어분과 2시간 정도의 진행 상황을 공유 및 피드백을 수리한 뒤에 기존에 있는 DB에 실험을 해봐야 겠다.
