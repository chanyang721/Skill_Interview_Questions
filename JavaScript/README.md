### 자바스크립트의 특징은 뭔가요 ?
자바스크립트의 특징은 동적 프로토타입 기반의 객체 지향 언어라는 것입니다.
객체 지향 언어이기 떄문에 OOP의 핵심 개념들을 구현하기 위해 프로토타입을 이용했습니다.


### 자바스크립트의 장점과 단점에 대해서 알려주세요
#### 자바스크립트의 장점
* 자바스크립트는 인터프리터 언어이기 때문에 실행 속도가 컴파일 언어에 빠르다는 장점과, 배우는데 비교적 쉬운 구조를 가지고 있습니다.
* 거의 모든 브라우저가 지원하기 때문에 많은 개발자들이 다양한 애플리케이션을 만들때 사용하는 언어로 사용되고 있습니다. 
* npm(node package manageer)을 통해 다양한 모듈을 사용할 수 있습니다.
* 백엔드에서도 사용 가능한 nodeJS라는 런타임 환경을 가지고 있어 서버 개발에도 사용할 수 있습니다.
* 다른 프로그래밍 언어와 호환되는 관계를 가지고 있기 때문에 임베드가 가능합니다.
#### 자바스크립트의 단점
* 자바스크립트 코드는 사용자가 손쉽게 확인 할 수 있기 때문에, 클라이언트 보안에 취약하며
* 다양한 브라우저에서 지원되지만 각 브라우저가 자바스크립트를 컴파일하는 인터프리터가 다르기 때문에 배포 전에 모든 브라우저에서 잘 돌아가는지 확인해야 합니다. 
* 코드상에 에러가 하나라도 있으면 렌더링이 전부 중지되기 때문에 소스 코드에 대한 테스트를 반드시 해야합니다.
* Java나 TypeScript의 class에서 제공하는 은닉화 키워드인 private을 지원하는 브라우저가 거의 없다는 단점이 있습니다.
* 추상화 기능 부제 => 인터페이스를 설정할 방법이 없다. 

### 함수형 프로그래밍이란 ?


### 함수의 목적을 설명해주세요
* 인풋을 아웃풋으로 만들기 위해 적용하기 위한 로직을 작성하기 하기 위한 코드의 집합입니다.
* 함수를 사용하는 가장 큰 이유는 반복되는 특정한 로직을 하나로 묶어서 필요할 때마다 함수명을 호출하여 간편하게 로직을 불러내기 위해 사용합니다.
* 

### 순수 함수란 ?


### var, let, const의 차이점 (중요) <br>
* var, let, const의 차이점은 재선언, 재할당, 스코프 단위에서 찾을 수 있다고 생각합니다.
* var는 재선언, 재할당이 가능하지만, 함수 단위의 스코프를 가지고 있으며, 글로벌 단위에서 선언 시 윈도우 객체에 포함되어 변수의 충돌이나 예측하기 힘든 오류가 발생하기 때문에 최근에는 사용하지 않고 있다고 알고 있습니다. 
* let은 재선언은 불가능하지만, 재할당은 가능하며, 블록 스코프를 가지고 있습니다. 
* const는 재선언, 재할당이 불가능한 선언문으로 블로 스코프를 가지고 있습니다.
  -> let은 변수의 재할당이 가능하다는 장점을 가지고 있지만, 이는 같은 변수 이름을 다르게 사용할 경우 에러의 가능성이 있기 때문에 const를 사용하는 것이 에러 발생을 줄일 수 있다고 생각합니다. 

### 호이스팅 (Hoisting)이 무엇인지 설명해주세요 (중요) <br>
* Hoist는 "끌어올리기" 라는 뜻으로, 자바스크립트 코드에서 작성된 순서와 상관없이 가장 먼저 선언되는 것을 호이스팅이라고 합니다. 
* 이러한 특징은 자바스크립트 엔진 구동시 선언을 가장 최우선으로 해석하기 때문에 발생합니다.
* 예를 들면 변수 선언문 중 var 키워드로 선언된 모든 변수와 함수 선언식은 자동적으로 호이스팅의 대상이 됩니다. 하지만, var로 선언된 변수의 할당된 값은 호이스팅의 대상이 아니기 때문에 변수에는 undefined 할당되어 호이스팅 됩니다.
* 변수에 할당은 런타임 과정에서 이루어 지기 때문에 호이스팅의 대상이 아닙니다.

### 클로저 (Closure) (중요) <br>
* 클로저란 두 개의 함수가 선언된 어휘적 환경의 조합으로, 이 어휘적 환경은 함수가 선언된 시점에서 접근 가능한 모든 지역 변수로 구성됩니다. 
* 따라서 클로저 함수란, 외부 함수의 변수에 접근할 수 있는 내부 함수를 말하며, 내부 함수에서는 지역 변수, 외부 함수의 변수, 전역 변수를 모두 사용할 수 있는 어휘적 환경을 가지게 됩니다.
* 자바사크립트에서 클로저의 역할은 변수와 메서드의 공개/비공개 여부를 결정하기 위한 방법입니다.
* 클로저를 생성하기 위한 조건으로는 3가지가 있습니다.
1. 내부 함수가 익명 함수로서 외부함수의 return 값으로 사용되는 경우
```js
function outer() {
  let name = `clouser`;
  return function () {
    console.log(name)
  }
}
```
2. 내부 함수가외부 함수의 실행 환경에서 실행되는 경우
```js
function outer() {
  let name = `closure`;
  function inner() {
    console.log(name);
  }
  inner(); 
}
outer();
// console> closure
```
3. 내부 함수의 환경에서 사용되는 변수가 외부 함수의 변수 스코프를 가지는 경우
```js
let name = `Warning`;
function outer() {
  let name = `closure`;
  return function inner() {
    console.log(name);
  };
}

let callFunc = outer();
callFunc();
// console> closure
```

### 커링(Currying) 이란 ? 


### this에 대해 아는 대로 설명해주세요. 함수를 선언하고 내부에 let a,b 선언하고 this.a를 호출할때의 상황에서 설명해주세요.) (중요) <br>
* 자바스크립트의 함수는 객체 타입으로 선언될 때마다 함수 내부에 암묵적으로 this라는 객체가 추가됩니다.
```js
/// 암묵적인 규칙 ///
function User(name) {
// this = {}; ⇒ 빈 객체가 만들어진다.
  this.name = name;
// return this ⇒ this가 반환된다.  
}

const user = new User("John")
user // ⇒ {name: "John"}
```
* 그렇기 때문에 this는 함수가 호출되는 상황에 따라 this의 값이 변하게 됩니다.
1. 객체(A)의 메서드(B) 호출 시, this는 A.B에서 A가 this가 됩니다. 
```js
const Obj = {
  name: "chanyang",
  sayName: function () {
    console.log(this)
  }
}
```
2. 함수 호출 시, A.B의 구조가 있으면 this는 A에 바인딩되지만, A.B의 구조가 없다면 전역 객체에 바인딩 됩니다.
```js
var value = 1000;
const Obj = {
  value: 10,
  func1: function () {
    console.log(`func1's this.value: ${this.value}`);

    let func2 = function () {
      console.log(`func2's this.value: ${this.value}`)
    }
    func2();
  }
}
Obj.func1();
// func1's this.value: 10
// func2's this.value: 1000
```
3. new 키워드로 생성자 함수를 호출하여 인스턴스 생성 시, this는 생성된 인스턴스가 됩니다.
```js
let Person = function (name) {
  console.log(this);
  this.name = name;
}

let student = new Person("chanyang");
console.log(student.name) // "chanyang"
```

### 원시값, 참조값 차이 및 개념 (중요) <br>
* 원시값과 참조값의 차이는 원시값은 저장 stack(변수)에 값 자체를 할당하지만, 참조값은 값을 heap이라는 동적 저장소에 저장이 되며, 저장 stack(변수)에는 heap의 주소를 할당한다는 차이가 있습니다. 
* heap이란 동적인 데이터가 저장되는 보관함을 말하며, 데이터 값을 줄줄이 연결지어 놓은 공간입니다.
* 참조값을 만든 이유는 원시 자료형으로 리스트 개념을 구현하기에는 데이터의 크기가 제한되어있을 뿐만 아니라, 어느 시점에 요소를 추가, 변경, 삭제같은 작업을 하는지 모르기 때문에, 해당 작업을 어느떄나 손쉽게 하기 위해서 만들었습니다.
* 원시값의 종류로는 number, string, boolean, null, undefined, symbol이 있으며, 참조값의 종류는 object, array, function이 있습니다. 

### 기존 자바스크립트와 ES6의 차이점 및 특징 (중요)
* 기존의 자바스크립트와 ES6의 차이점은 ES6부터 추가된 화살표함수, 라스트파라미터(...), 디폴트파라미터, for/of문, 템플릿 리터럴(`${}`)와 같은 다른 언어에서 제공되는 다양한 기능을 사용할 수 있다는 것입니다. 
* Class라는 문법이 추가되어 프로토타입으로 인스턴스를 생성해야 했던 불편함을 해소했습니다.

### Promise 관련 개념 → 무엇인지, 왜 사용하게 되었는지, 어떤 특징이 있는지 등등 (중요)
* 프로미스는 동기적으로 작동하는 자바스크립트에서 비동기적인 작동을 위해 만들어진 하나의 도구로 객체 형태의 리턴값을 가지고 있습니다. 우선 동기와 비동기를 간략하게 설명하자면 동기는 한번에 하나의 일만, 비동기는 한번에 여러가지 일을 할 수 있다는 프로세스입니다. 동기적으로 작동하는 언어인 자바스크립트에서 비동기적인 작동을 구현하기 위해 프로미스가 만들어졌습니다. 사실 프로미스 이전에 콜백함수를 사용하여 코드의 응답의 순서를 예측하거나 제어하기 위해 사용했었다고 알고 있습니다. 하지만, 콜백함수를 규모가 큰 프로젝트에서 사용하면 피라미드 형태로 쌓이는 콜백 헬이 만들어지게 되어 이를 가독성 측면에서 보안한 프로미스를 만들었다고 알고 있습니다. 프로미스는 then과 catch 그리고 finally라는 내장 메서드를 이용합니다. 비동기 작업의 결과를 then의 매계변수로 자동적으로 할당받아 작업을 순차적으로 실행하며, 만약 작업에서 오류가 생성된다면 그것을 catch의 매계변수로 받아 에러 핸들링을 한다고 알고 있습니다. 마지막으로 finally라는 메서드는 비동기 작업의 성공이나 실패에 상관없이 반드시 실행하고 싶은 부분을 넣는 함수입니다. 만약에 이러한 작업들을 병렬적으로 실행하기 위한 메서드인 Promise.all을 사용한다면, 해당 프로미스객체의 결과를 요소로 하는 배열을 리턴받을 수 있는 것으로 알고 있습니다. 


### 트렌젝션 개념 및 단계에 대한 설명 (중요)
